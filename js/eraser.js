// Generated by CoffeeScript 1.6.2
(function() {
  
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating 
// requestAnimationFrame polyfill by Erik MÃ¶ller
// fixes from Paul Irish and Tino Zijdel
 (function() {
	var lastTime = 0;
	var vendors = ['ms', 'moz', 'webkit', 'o'];
	for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
		window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
		window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame']
								   || window[vendors[x]+'CancelRequestAnimationFrame'];
	}
	if (!window.requestAnimationFrame) {
		window.requestAnimationFrame = function(callback, element) {
			var currTime = new Date().getTime();
			var timeToCall = Math.max(0, 16 - (currTime - lastTime));
			var id = window.setTimeout(function() { callback(currTime + timeToCall); },
			  timeToCall);
			lastTime = currTime + timeToCall;
			return id;
		};
	}
	if (!window.cancelAnimationFrame) {
		window.cancelAnimationFrame = function(id) {
			clearTimeout(id);
		};
	}
}());
;
  var CupcakeSprite, EMPTY, HeroSprite, ImageGroup, K, Pencil, STATUS_FALLING, STATUS_WALKING, TAU, TILE_HEIGHT, TILE_SIZE, TILE_WIDTH, Tile, WALL, World, canvas, deltaSeconds, drawBackground, dt, g, images, mouseDown, mousePressed, mouseReleased, mouseX, mouseY, pencil, pixToTile, queueFrame, rawMillis, seconds, setMessage, setupTest, time, world;

  ImageGroup = (function() {
    function ImageGroup(paths) {
      var path, stripName, _fn, _i, _len,
        _this = this;

      stripName = function(path) {
        var i, result, s, tokens, _i, _ref;

        result = path.replace(/^.*[\\\/]/, '').split('.')[0];
        if (result.indexOf("_") !== -1) {
          tokens = result.split('_');
          result = tokens[0];
          for (i = _i = 1, _ref = tokens.length - 1; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
            s = tokens[i];
            result = result + s[0].toUpperCase() + s.substring(1, s.length);
          }
        }
        return result;
      };
      this.numLoading = paths.length;
      this.numFailed = 0;
      _fn = function(path) {
        var img;

        img = new Image();
        img.onload = function() {
          return _this.numLoading--;
        };
        img.onerror = img.onabort = function() {
          _this.numLoading--;
          return _this.numFailed++;
        };
        img.src = path;
        return _this[stripName(path)] = img;
      };
      for (_i = 0, _len = paths.length; _i < _len; _i++) {
        path = paths[_i];
        _fn(path);
      }
    }

    ImageGroup.prototype.loading = function() {
      return this.numLoading > 0;
    };

    ImageGroup.prototype.complete = function() {
      return this.numLoading === 0 && this.numFailed === 0;
    };

    ImageGroup.prototype.failed = function() {
      return this.numFailed > 0;
    };

    return ImageGroup;

  })();

  TAU = Math.PI + Math.PI;

  setMessage = function(msg) {
    return $('#logger').html(msg);
  };

  canvas = null;

  g = null;

  mouseX = 0;

  mouseY = 0;

  mousePressed = false;

  mouseReleased = false;

  mouseDown = false;

  rawMillis = function() {
    return new Date().getTime();
  };

  dt = 0;

  time = 0;

  seconds = function() {
    return 0.001 * time;
  };

  deltaSeconds = function() {
    return 0.001 * dt;
  };

  images = new ImageGroup(['images/pencil.png', 'images/background.jpg', 'images/walk.png', 'images/cupcake.png']);

  pencil = null;

  world = null;

  queueFrame = function(state) {
    dt = rawMillis() - time;
    time = rawMillis();
    dt = Math.min(dt, 33);
    mousePressed = false;
    mouseReleased = false;
    return requestAnimationFrame(state);
  };

  drawBackground = function() {
    return g.drawImage(images.background, 0, 0);
  };

  Pencil = (function() {
    function Pencil() {
      this.rubTime = 0;
    }

    Pencil.prototype.draw = function() {
      var angle, dx, dy, u;

      g.save();
      dx = mouseX - (canvas.width >> 1);
      dy = mouseY - (0.666 * canvas.height);
      angle = Math.atan2(dy, dx);
      g.translate(mouseX, mouseY);
      g.rotate(angle + Math.PI);
      if (!mouseDown) {
        g.drawImage(images.pencil, -images.pencil.width, -10);
      } else {
        if (mousePressed) {
          this.rubTime = 0;
        } else {
          this.rubTime += deltaSeconds();
        }
        u = 0.5 * Math.sin(TAU * 5 * this.rubTime);
        g.drawImage(images.pencil, u * 20 - images.pencil.width, -u * 4 - 10);
      }
      return g.restore();
    };

    return Pencil;

  })();

  TILE_SIZE = 32;

  K = 1.0 / 32.0;

  TILE_WIDTH = 26;

  TILE_HEIGHT = 16;

  EMPTY = 0;

  WALL = 1;

  pixToTile = function(x) {
    return Math.floor(K * x);
  };

  Tile = (function() {
    function Tile(i) {
      this.x = i % TILE_WIDTH;
      this.y = (i - this.x) / TILE_WIDTH;
      this.type = EMPTY;
    }

    Tile.prototype.clear = function() {
      return this.type = EMPTY;
    };

    Tile.prototype.isSolid = function() {
      return this.type === WALL;
    };

    Tile.prototype.draw = function() {
      if (this.type === WALL) {
        g.fillStyle = 'rgba(24, 24, 48, 1.0)';
        return g.fillRect(this.x * TILE_SIZE, this.y * TILE_SIZE, TILE_SIZE - 1, TILE_SIZE - 1);
      }
    };

    return Tile;

  })();

  STATUS_WALKING = 0;

  STATUS_FALLING = 1;

  HeroSprite = (function() {
    function HeroSprite() {
      this.x = 0;
      this.y = 0;
      this.vx = 0;
      this.vy = 0;
      this.status = STATUS_WALKING;
    }

    HeroSprite.prototype.tick = function() {
      var top, x, xnext, xprev, y, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;

      switch (this.status) {
        case STATUS_WALKING:
          xprev = pixToTile(this.x);
          this.x += this.vx * deltaSeconds();
          xnext = pixToTile(this.x);
          if (xnext !== xprev) {
            top = pixToTile(this.y);
            if (this.vx > 0) {
              if (!((_ref = world.getTile(xnext, top + 2)) != null ? _ref.isSolid() : void 0)) {
                this.x = TILE_SIZE * xnext;
                this.vy = 128;
                return this.status = STATUS_FALLING;
              } else if (((_ref1 = world.getTile(xnext + 1, top)) != null ? _ref1.isSolid() : void 0) || ((_ref2 = world.getTile(xnext + 1, top + 1)) != null ? _ref2.isSolid() : void 0)) {
                this.vx = -this.vx;
                return this.x = TILE_SIZE * xnext;
              }
            } else {
              if (!((_ref3 = world.getTile(xnext + 1, top + 2)) != null ? _ref3.isSolid() : void 0)) {
                this.x = TILE_SIZE * (xnext + 1);
                this.vy = 128;
                return this.status = STATUS_FALLING;
              } else if (((_ref4 = world.getTile(xnext, top)) != null ? _ref4.isSolid() : void 0) || ((_ref5 = world.getTile(xnext, top + 1)) != null ? _ref5.isSolid() : void 0)) {
                this.vx = -this.vx;
                return this.x = TILE_SIZE * (xnext + 1);
              }
            }
          }
          break;
        case STATUS_FALLING:
          this.vy += 1024 * deltaSeconds();
          this.y += this.vy * deltaSeconds();
          x = pixToTile(this.x);
          y = pixToTile(this.y) + 2;
          if ((_ref6 = world.getTile(x, y)) != null ? _ref6.isSolid() : void 0) {
            this.vy = 0;
            this.y -= this.y % TILE_SIZE;
            return this.status = STATUS_WALKING;
          }
      }
    };

    HeroSprite.prototype.draw = function() {
      var frame, h, w;

      frame = Math.floor(seconds() * 10) % 10;
      w = images.walk.width;
      h = images.walk.height / 10;
      if (this.vx < 0) {
        g.save();
        g.translate(this.x - 6, this.y);
        g.translate(w / 2, 0);
        g.scale(-1, 1);
        g.drawImage(images.walk, 0, frame * h, w, h, -w / 2, 0, w, h);
        return g.restore();
      } else {
        return g.drawImage(images.walk, 0, frame * h, w, h, this.x - 6, this.y, w, h);
      }
    };

    return HeroSprite;

  })();

  CupcakeSprite = (function() {
    function CupcakeSprite() {
      this.x = 0;
      this.y = 0;
    }

    CupcakeSprite.prototype.draw = function() {
      var frame, h, w;

      frame = Math.floor(seconds() * 7.5) % 6;
      w = images.cupcake.width;
      h = images.cupcake.height / 6;
      return g.drawImage(images.cupcake, 0, frame * h, w, h, this.x, this.y + 5, w, h);
    };

    return CupcakeSprite;

  })();

  World = (function() {
    function World() {
      var i;

      this.offsetX = 0.5 * (canvas.width - TILE_SIZE * TILE_WIDTH) + 2;
      this.offsetY = 0.5 * (canvas.height - TILE_SIZE * TILE_HEIGHT) + 20;
      this.tiles = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = TILE_WIDTH * TILE_HEIGHT - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(new Tile(i));
        }
        return _results;
      })();
      this.hero = new HeroSprite;
      this.cupcake = new CupcakeSprite;
    }

    World.prototype.tick = function() {
      var tile;

      if (mouseDown) {
        tile = this.tileUnder(mouseX, mouseY);
        if (tile != null) {
          tile.clear();
        }
      }
      return this.hero.tick();
    };

    World.prototype.draw = function() {
      var tile, _i, _len, _ref;

      g.save();
      g.translate(this.offsetX, this.offsetY);
      _ref = this.tiles;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tile = _ref[_i];
        tile.draw();
      }
      this.cupcake.draw();
      this.hero.draw();
      return g.restore();
    };

    World.prototype.getTile = function(x, y) {
      if (x >= 0 && x < TILE_WIDTH && y >= 0 && y < TILE_HEIGHT) {
        return this.tiles[Math.floor(x) + TILE_WIDTH * Math.floor(y)];
      } else {
        return null;
      }
    };

    World.prototype.tileUnder = function(px, py) {
      return this.getTile(Math.floor((px - this.offsetX) / TILE_SIZE), Math.floor((py - this.offsetY) / TILE_SIZE));
    };

    return World;

  })();

  setupTest = function() {
    var i, _i, _j, _k, _ref, _ref1;

    for (i = _i = 0, _ref = TILE_WIDTH - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      world.getTile(i, 15).type = WALL;
    }
    for (i = _j = 0; _j <= 4; i = ++_j) {
      world.getTile(i, 11).type = WALL;
    }
    for (i = _k = 0, _ref1 = TILE_HEIGHT - 1; 0 <= _ref1 ? _k <= _ref1 : _k >= _ref1; i = 0 <= _ref1 ? ++_k : --_k) {
      world.getTile(0, i).type = WALL;
      world.getTile(10, i).type = WALL;
    }
    world.hero.x = 32;
    world.hero.y = 9 * 32;
    world.hero.vx = 128;
    world.cupcake.x = 20 * 32;
    return world.cupcake.y = 13 * 32;
  };

  $(function() {
    var doGameplay, doc;

    canvas = $('canvas')[0];
    if ((canvas != null ? canvas.getContext : void 0) == null) {
      alert('HTML5 Required, Dude');
      return;
    }
    g = canvas.getContext('2d');
    doc = $(this);
    doc.mousemove(function(e) {
      mouseX = e.pageX - canvas.offsetLeft;
      return mouseY = e.pageY - canvas.offsetTop;
    });
    doc.mousedown(function(e) {
      mouseX = e.pageX - canvas.offsetLeft;
      mouseY = e.pageY - canvas.offsetTop;
      mouseDown = true;
      mousePressed = true;
      if (mouseX >= 0 && mouseX < canvas.width && mouseY >= 0 && mouseY < canvas.height) {
        return e.preventDefault();
      }
    });
    doc.mouseup(function(e) {
      mouseX = e.pageX - canvas.offsetLeft;
      mouseY = e.pageY - canvas.offsetTop;
      mouseDown = false;
      mouseReleased = true;
      if (mouseX >= 0 && mouseX < canvas.width && mouseY >= 0 && mouseY < canvas.height) {
        return e.preventDefault();
      }
    });
    time = rawMillis();
    pencil = new Pencil;
    world = new World;
    setupTest();
    doGameplay = function() {
      drawBackground();
      world.tick();
      world.draw();
      pencil.draw();
      return queueFrame(doGameplay);
    };
    return (function() {
      if (images.loading()) {
        if (images.failed()) {
          return alert("Eek! Failed to load Assets :*(");
        } else {
          return queueFrame(arguments.callee);
        }
      } else {
        return queueFrame(doGameplay);
      }
    })();
  });

}).call(this);
